## Урок 4. Порождающие паттерны
* 0:19 start
* 0:21 born patterns
* 0:29 factory
* 0:38 abc_factory
* 0:49 prototype
* 0:54 relax 1:04
* 1:05 builder
* 1:15 singleton
* 1:23 hw

## Задания 4
#### В этой самостоятельной работе тренируем умения:
1. Выбирать подходящий порождающий шаблон.
2. Применять порождающие шаблоны в своём коде.
#### Зачем:
Для использования порождающих шаблонов в своём коде.

#### Последовательность действий:
0. На базе нашего WSGI-фреймворка мы начинаем делать обучающий сайт, чтобы на нём
отработать навыки применения шаблонов проектирования.
1. Тема (чему мы будем обучать) может быть любая, что вам больше нравится (например:
горные лыжи, йога, администрирование, фридайвинг, продажи, …).
2. Минимальное описание работы сайта следующее:
   - a. На сайте есть курсы по обучению чему-либо. Курс относится к какой-либо категории.
   Например, есть курсы обучения программированию на Python, Java, JavaScript. И
   курсы Python для новичков, Java для профи, …
   - b. Также на сайте есть студенты, которые могут записаться на один или несколько
   курсов.
3. Это минимальный функционал, на котором мы будем отрабатывать шаблоны, можно будет его
расширить.
4. В домашнем задании требуется добавить следующий функционал:
   - a. Создание категории курсов.
   - b. Вывод списка категорий.
   - c. Создание курса.
   - d. Вывод списка курсов.
5. Далее можно сделать всё или одно на выбор, применив при этом один из порождающих
паттернов, либо аргументировать, почему паттерны не были использованы:
   - a. На сайте могут быть курсы разных видов: офлайн (вживую), для них указывается
адрес проведения, и онлайн (вебинары), для них указывается вебинарная система.
Также известно, что в будущем могут добавиться новые виды курсов.
   - b. Реализовать простой логгер (не используя сторонние библиотеки). У логгера есть имя.
Логгер с одним и тем же именем пишет данные в один и тот же файл, а с другим
именем — в другой.
   - c. Реализовать страницу для копирования уже существующего курса, чтобы не создавать
его снова с нуля, а скопировать существующий и немного отредактировать.


[//]: # (## Урок 3. Принципы проектирования)
[//]: # (* 0:11 start)
[//]: # (* 0:14 principles)
[//]: # (* 0:21 methods)
[//]: # (* 0:26 dry)
[//]: # (* 0:29 kiss)
[//]: # (* 0:32 solid)
[//]: # (* 0:34 srp)
[//]: # (* 0:42 ocp)
[//]: # (* 0:56 isp)
[//]: # (* 1:01 dip)
[//]: # (* 1:09 relax 1:19)
[//]: # (* 1:19 lsp)
[//]: # (* 1:32 grasp)
[//]: # (* 1:33 hw)
[//]: # ()
[//]: # (## Задания 3)
[//]: # (**В этой самостоятельной работе тренируем умения:**)
[//]: # (1. Работать с шаблонизатором)
[//]: # (2. Использовать базовые и включенные шаблоны)
[//]: # ()
[//]: # (<br>**Смысл:**)
[//]: # (<br>Для того чтобы избегать дублирования в шаблонах)
[//]: # ()
[//]: # (**Последовательность действий:**)
[//]: # (0. Внести изменения в wsgi-фреймворк, которые позволят использовать механизм наследования и включения шаблонов)
[//]: # (1. Создать базовый шаблон для всех страниц сайта)
[//]: # (2. Если нужно создать один или несколько включенных шаблонов)
[//]: # (3. Добавить на сайт меню, которое будет отображаться на всех страницах)
[//]: # (4. Улучшить имеющиеся страницы с использованием базовых и включенных шаблонов)
[//]: # (5. Проверить что фреймворк готов для дальнейшего использования при желании добавить какой либо полезный функционал)
[//]: # (## Урок 2. Архитектура python-приложений)
[//]: # (* 0:10 start)
[//]: # (* 0:17 description)
[//]: # (* 0:36 advantages)
[//]: # (* 0:43 principles)
[//]: # (* 0:55 criteria)
[//]: # (* 1:06 erosion)
[//]: # (* 1:09 types)
[//]: # (* 1:10 client-server)
[//]: # (* 1:12 multilayer)
[//]: # (* 1:18 DDD)
[//]: # (* 1:19 SOA)
[//]: # (* 1:22 ESB)
[//]: # (* 1:24 relax 1:34)
[//]: # (* 1:35 wsgi)
[//]: # (* 1:46 hw)
[//]: # (## Задания 2)
[//]: # (**В этой самостоятельной работе тренируем умения:**)
[//]: # (1. Разделять get и post запрос внутри wsgi-фреймворка)
[//]: # (2. Получать и декодировать параметры post запроса)
[//]: # (<br>**Смысл:**)
[//]: # (<br>Чтобы уметь обрабатывать разные типы web-запросов)
[//]: # (**Последовательность действий:**)
[//]: # (0. Добавить в свой wsgi-фреймворк возможность обработки post-запроса)
[//]: # (1. Добавить в свой wsgi-фреймворк возможность получения данных из post запроса)
[//]: # (2. Дополнительно можно добавить возможность получения данных из get запроса)
[//]: # (3. В проект добавить страницу контактов на которой пользователь может отправить нам сообщение &#40;пользователь вводит тему сообщения, его текст, свой email&#41;)
[//]: # (4. После отправки реализовать сохранение сообщения в файл, либо вывести сообщение в терминал &#40;базу данных пока не используем&#41;)
[//]: # (## Урок 1. Паттерны web-представления)
[//]: # (* 0:10 startweb)
[//]: # (* 0:15 description)
[//]: # (* 0:25 mvc)
[//]: # (* 0:34 page controller)
[//]: # (* 0:37 front controller)
[//]: # (* 0:43 wsgi)
[//]: # (* 0:54 ubuntu)
[//]: # (* 0:59 fwsgi)
[//]: # (* 1:01 -2)
[//]: # (* 1:03 -3)
[//]: # (* 1:05 -4)
[//]: # (* 1:07 -5)
[//]: # (* 1:08 -6 routes)
[//]: # (* 1:10 -7)
[//]: # (* 1:11 relax 1:21)
[//]: # (* 1:22 -8 html)
[//]: # (* 1:24 -9 request)
[//]: # (* 1:29 -10 front)
[//]: # (* 1:34 pip install jinja2)
[//]: # (* 1:36 templator)
[//]: # (* 1:40 hw)
[//]: # ()
[//]: # (## Задания 1)
[//]: # (###В этой самостоятельной работе тренируем умения:)
[//]: # (1. Использовать паттерны page controller, front controller)
[//]: # (2. Использовать шаблонизатор)
[//]: # (### Смысл:)
[//]: # (Понимать и применять паттерны page и front controllers, понимать как устроены и работают wsgi фреймворки. Использовать шаблонизаторы)
[//]: # (###Последовательность действий:)
[//]: # (0. Создать репозиторий для нового проекта &#40;gitlab, github, ...&#41;)
[//]: # (1. С помощью uwsgi или gunicorn запустить пример simple_wsgi.py, проверить что он работает &#40;Эти библиотеки работают на linux системах, документацию по ним можно найти в дополнительных материалах&#41;)
[//]: # (2. Написать свой wsgi фреймворк использую паттерны page controller и front controller.)
[//]: # (<br>Описание работы фреймворка:)
[//]: # (<br>возможность отвечать на get запросы пользователя &#40;код ответа + html страница&#41;)
[//]: # (<br>для разных url - адресов отвечать разными страницами)
[//]: # (<br>page controller - возможность без изменения фреймворка добавить view для обработки нового адреса)
[//]: # (<br>front controller - возможность без изменения фреймворка вносить изменения в обработку всех запросов)
[//]: # (3. Реализовать рендеринг страниц с помощью шаблонизатора jinja2. Документацию по этой библиотеке можно найти в дополнительных материалах)
[//]: # (4. Добавить любый полезный функционал в фреймворк, например обработку наличия &#40;отсутствия&#41; слеша в конце адреса, ...)
[//]: # (5. Добавить для демонстрации 2 любые разные страницы &#40;например главная и about или любые другие&#41;)
[//]: # (6. Сдать дз в виде ссылки на репозиторий)
[//]: # (7. В readme указать пример как запустить фреймворк с помощью uwsgi и/или gunicorn)
